<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>화살표 함수</title>
</head>
<body>
    <script>
        // 객체의 상태 : 객체가 가지는 고유한 값 (this 로 구별)
        // 정적 멤버 : 상태를 사용하지 않는다 → this 가 없다
                    // Math. round(3.7)
                    // Math. round(3.14)
                        // 항상 출력된 값이 똑같음
        // 객체는 필드와 메소드를 가진다
        // 메소드는 자신이 속한 객체의 필드(상태)로 작업한다
        // 그런데 효율성을 위해서 메소드를 객체와 분리시켰다 → why? 처리하는 코드는 1개만 있으면 된다
        // 그럼 이제 메소드는 자신의 필드를 어떻게 구별하지? → this (이렇게 해서 this 가 나오게 됨)
        // 자바스크립트는 this 가 생략이 안 됨 무조건 적어줘야함 
        // 상태 (state) : 객체마다 다른 정보들
        //  - 일반 피드, 일반 메소드
        // 정적 (static) : 상태가 아닌 정보 (객체의 고유한 값이나 기능이 아니다) → 클래스 소속으로 객체들이 공유
        //  - 정적, 정적 메소드
                // Math.sum(10,20)  ← 상태가 없는 것 (상태가 있으면 항상 같은 입력, 같은 출력을 함)
        

        const obj = {
            irum : '홍길동',
            nai : 20,
            print1: function() {
                // JS 는 메소드에서 필드에 접근하려면 this 를 명시적으로 사용 (자바는 써도 그만, 안 써도 그만 안 쓰면 자동으로 추가 함)
                // 자바에서 this 는 항상 자신이 속한 객체를 가리킨다
                // JS 에서 this 는 상황에 따라 달라진다
                // 일반 함수를 메소드로 사용한 경우 this 는 자신이 속한 객체
                console.log(this.irum);
                // print1 이 obj 객체 소속이므로 this 는 obj
                console.log(this);
            },
            print2:()=> {
                console.log(this.irum); // ← undefined 발생
                // ↑ 를 출력하면 Window 라는 최상위 브라우저가 출력됨
                // 화살표 함수의 this 는 window 객체 → 화살표 함수는 메소드로 사용해서는 안된다
                console.log(this);
            }
        };

        obj.print1();
        obj.print2();
    </script>
</body>
</html>